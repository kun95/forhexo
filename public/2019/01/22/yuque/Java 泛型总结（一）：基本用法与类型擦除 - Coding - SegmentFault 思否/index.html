<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Java 泛型总结（一）：基本用法与类型擦除 - Coding - SegmentFault 思否 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="简介Java 在 1.5 引入了泛型机制，泛型本质是参数化类型，也就是说变量的类型是一个参数，在使用时再指定为具体类型。泛型可以用于类、接口、方法，通过使用泛型可以使代码更简单、安全。然而 Java 中的泛型使用了类型擦除，所以只是伪泛型。这篇文章对泛型的使用以及存在的问题做个总结，主要参考自 《Java 编程思想》。 这个系列的另外两篇文章：  Java 泛型总结（二）：泛型与数组  Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 泛型总结（一）：基本用法与类型擦除 - Coding - SegmentFault 思否">
<meta property="og:url" content="http://yoursite.com/2019/01/22/yuque/Java 泛型总结（一）：基本用法与类型擦除 - Coding - SegmentFault 思否/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="简介Java 在 1.5 引入了泛型机制，泛型本质是参数化类型，也就是说变量的类型是一个参数，在使用时再指定为具体类型。泛型可以用于类、接口、方法，通过使用泛型可以使代码更简单、安全。然而 Java 中的泛型使用了类型擦除，所以只是伪泛型。这篇文章对泛型的使用以及存在的问题做个总结，主要参考自 《Java 编程思想》。 这个系列的另外两篇文章：  Java 泛型总结（二）：泛型与数组  Java">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-06-25T04:51:16.210Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java 泛型总结（一）：基本用法与类型擦除 - Coding - SegmentFault 思否">
<meta name="twitter:description" content="简介Java 在 1.5 引入了泛型机制，泛型本质是参数化类型，也就是说变量的类型是一个参数，在使用时再指定为具体类型。泛型可以用于类、接口、方法，通过使用泛型可以使代码更简单、安全。然而 Java 中的泛型使用了类型擦除，所以只是伪泛型。这篇文章对泛型的使用以及存在的问题做个总结，主要参考自 《Java 编程思想》。 这个系列的另外两篇文章：  Java 泛型总结（二）：泛型与数组  Java">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-yuque/Java 泛型总结（一）：基本用法与类型擦除 - Coding - SegmentFault 思否" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/22/yuque/Java 泛型总结（一）：基本用法与类型擦除 - Coding - SegmentFault 思否/" class="article-date">
  <time datetime="2019-01-22T04:56:27.000Z" itemprop="datePublished">2019-01-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java 泛型总结（一）：基本用法与类型擦除 - Coding - SegmentFault 思否
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a name="y1fsyh"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><a href="#y1fsyh"></a>简介</h2><p>Java 在 1.5 引入了泛型机制，泛型本质是参数化类型，也就是说变量的类型是一个参数，在使用时再指定为具体类型。泛型可以用于类、接口、方法，通过使用泛型可以使代码更简单、安全。然而 Java 中的泛型使用了类型擦除，所以只是伪泛型。这篇文章对泛型的使用以及存在的问题做个总结，主要参考自 《Java 编程思想》。</p>
<p>这个系列的另外两篇文章：</p>
<ul>
<li><p><a href="https://segmentfault.com/a/1190000005179147" target="_blank" rel="noopener">Java 泛型总结（二）：泛型与数组</a></p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000005337789" target="_blank" rel="noopener">Java 泛型总结（三）：通配符的使用</a></p>
</li>
</ul>
<p><a name="rp66wu"></a></p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a><a href="#rp66wu"></a>基本用法</h2><p><a name="3kpkow"></a></p>
<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a><a href="#3kpkow"></a>泛型类</h3><p>如果有一个类 <code>Holder</code> 用于包装一个变量，这个变量的类型可能是任意的，怎么编写 <code>Holder</code> 呢？在没有泛型之前可以这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder1</span><span class="params">(Object a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Holder1 holder1 = <span class="keyword">new</span> Holder1(<span class="string">"not Generic"</span>);</span><br><span class="line">        String s = (String) holder1.get();</span><br><span class="line">        holder1.set(<span class="number">1</span>);</span><br><span class="line">        Integer x = (Integer) holder1.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;j</span><br></pre></td></tr></table></figure>

<p>在 <code>Holder1</code> 中，有一个用 <code>Object</code> 引用的变量。因为任何类型都可以向上转型为 <code>Object</code>，所以这个 <code>Holder</code> 可以接受任何类型。在取出的时候 <code>Holder</code> 只知道它保存的是一个 <code>Object</code> 对象，所以要强制转换为对应的类型。在 <code>main</code> 方法中， <code>holder1</code> 先是保存了一个字符串，也就是 <code>String</code> 对象，接着又变为保存一个 <code>Integer</code> 对象(参数 <code>1</code> 会自动装箱)。从 <code>Holder</code> 中取出变量时强制转换已经比较麻烦，这里还要记住不同的类型，要是转错了就会出现运行时异常。</p>
<p>下面看看 <code>Holder</code> 的泛型版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder2</span><span class="params">(T a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Holder2&lt;String&gt; holder2 = <span class="keyword">new</span> Holder2&lt;&gt;(<span class="string">"Generic"</span>);</span><br><span class="line">        String s = holder2.get();</span><br><span class="line"></span><br><span class="line">        holder2.set(<span class="string">"test"</span>);</span><br><span class="line">        holder2.set(<span class="number">1</span>); <span class="comment">// 编译不通过</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>Holder2</code> 中， 变量 <code>a</code> 是一个参数化类型 <code>T</code>，T`` 只是一个标识，用其它字母也是可以的。创建 <code>Holder2</code> 对象的时候，在尖括号中传入了参数 <code>T</code> 的类型，那么在这个对象中，所有出现 <code>T</code> 的地方相当于都用 <code>String</code> 替换了。现在的 <code>get</code> 的取出来的不是 <code>Object</code> ，而是 <code>String</code> 对象，因此不需要类型转换。另外，当调用 <code>set</code> 时，只能传入 <code>String</code> 类型，否则编译无法通过。这就保证了 <code>holder2</code> 中的类型安全，避免由于不小心传入错误的类型。</p>
<p>通过上面的例子可以看出泛使得代码更简便、安全。引入泛型之后，Java 库的一些类，比如常用的容器类也被改写为支持泛型，我们使用的时候都会传入参数类型，如：<code>ArrayList&lt;Integer&gt; list = ArrayList&lt;&gt;();</code>。</p>
<p><a name="1fk2uo"></a></p>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a><a href="#1fk2uo"></a>泛型方法</h3><p>泛型不仅可以针对类，还可以单独使某个方法是泛型的，举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethod</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果在参数中使用了泛型，那么在函数的签名上要用尖括号表现出泛型</span></span><br><span class="line">    <span class="keyword">public</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(K k,V v)</span> </span>&#123;</span><br><span class="line">        System.out.println(k.getClass().getSimpleName());</span><br><span class="line">        System.out.println(v.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericMethod gm = <span class="keyword">new</span> GenericMethod();</span><br><span class="line">        gm.f(<span class="keyword">new</span> Integer(<span class="number">0</span>),<span class="keyword">new</span> String(<span class="string">"generic"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">代码输出：</span><br><span class="line">    Integer</span><br><span class="line">    String</span><br></pre></td></tr></table></figure>

<p><code>GenericMethod</code> 类本身不是泛型的，创建它的对象的时候不需要传入泛型参数，但是它的方法 <code>f</code> 是泛型方法。在返回类型之前是它的参数标识 <code>&lt;K,V&gt;</code>，注意这里有两个泛型参数，所以泛型参数可以有多个。</p>
<p>调用泛型方法时可以不显式传入泛型参数，上面的调用就没有。这是因为编译器会使用参数类型推断，根据传入的实参的类型 (这里是 <code>integer</code> 和 <code>String</code>) 推断出 <code>K</code> 和 <code>V</code> 的类型。</p>
<p><a name="ffqotm"></a></p>
<h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a><a href="#ffqotm"></a>类型擦除</h2><p><a name="e4r1ku"></a></p>
<h3 id="什么是类型擦除"><a href="#什么是类型擦除" class="headerlink" title="什么是类型擦除"></a><a href="#e4r1ku"></a>什么是类型擦除</h3><p>Java 的泛型使用了类型擦除机制，这个引来了很大的争议，以至于 Java 的泛型功能受到限制，只能说是”伪泛型“。什么叫类型擦除呢？简单的说就是，类型参数只存在于编译期，在运行时，Java 的虚拟机 ( JVM ) 并不知道泛型的存在。先看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErasedTypeEquivalence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class c1 = <span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">        Class c2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码有两个不同的 <code>ArrayList</code>：<code>ArrayList&lt;Integer&gt;</code> 和 <code>ArrayList&lt;String&gt;</code>。在我们看来它们的参数化类型不同，一个保存整性，一个保存字符串。但是通过比较它们的 <code>Class</code> 对象，上面的代码输出是 <code>true</code>。这说明在 JVM 看来它们是同一个类。而在 C++、C# 这些支持真泛型的语言中，它们就是不同的类。</p>
<p>泛型参数会擦除到它的第一个边界，比如说上面的 <code>Holder2</code> 类，参数类型是一个单独的 <code>T</code>，那么就擦除到 <code>Object</code>,相当于所有出现 <code>T</code> 的地方都用 <code>Object</code> 替换。所以在 JVM 看来，保存的变量 <code>a</code> 还是 <code>Object</code> 类型。之所以取出来自动就是我们传入的参数类型，这是因为编译器在编译生成的字节码文件中插入了类型转换的代码，不需要我们手动转型了。如果参数类型有边界那么就擦除到它的第一个边界，这个下一节再说。<br>简而言之：在代码层面，虽有泛型的存在，但是在运行时候的jvm层面却感受不到泛型的存在</p>
<p><a name="gkovvz"></a></p>
<h3 id="擦除带来的问题"><a href="#擦除带来的问题" class="headerlink" title="擦除带来的问题"></a><a href="#gkovvz"></a>擦除带来的问题</h3><p>擦除会出现一些问题，下面是一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasF</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HasF.f()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manipulator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manipulator</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj.f(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HasF hasF  = <span class="keyword">new</span> HasF();</span><br><span class="line">        Manipulator&lt;HasF&gt; manipulator = <span class="keyword">new</span> Manipulator&lt;&gt;(hasF);</span><br><span class="line">        manipulator.manipulate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 <code>Manipulator</code> 是一个泛型类，内部用一个泛型化的变量 <code>obj</code>，在 <code>manipulate</code> 方法中，调用了 <code>obj</code> 的方法 <code>f()</code>，但是这行代码无法编译。因为类型擦除，编译器不确定 <code>obj</code> 是否有 <code>f()</code> 方法。解决这个问题的方法是给 <code>T</code> 一个边界:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulator2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasF</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manipulator2</span><span class="params">(T x)</span> </span>&#123; obj = x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123; obj.f(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在 <code>T</code> 的类型是 <code>&lt;T extends HasF&gt;</code>，这表示 T<code>必须是 HasF</code> 或者 HasF`` 的导出类型。这样，调用 <code>f()</code> 方法才安全。<code>HasF</code> 就是 <code>T</code> 的边界，因此通过类型擦除后，所有出现 <code>T</code> 的<br>地方都用 <code>HasF</code> 替换。这样编译器就知道 <code>obj</code> 是有方法 <code>f()</code> 的。</p>
<p>但是这样就抵消了泛型带来的好处，上面的类完全可以改成这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulator3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HasF obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manipulator3</span><span class="params">(HasF x)</span> </span>&#123; obj = x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123; obj.f(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以泛型只有在比较复杂的类中才体现出作用。但是像 <code>&lt;T extends HasF&gt;</code> 这种形式的东西不是完全没有意义的。如果类中有一个返回 <code>T</code> 类型的方法，泛型就有用了，因为这样会返回准确类型。比如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReturnGenericType</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasF</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReturnGenericType</span><span class="params">(T x)</span> </span>&#123; obj = x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> obj; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>get()</code> 方法返回的是泛型参数的准确类型，而不是 <code>HasF</code>。</p>
<p><a name="i1rmga"></a></p>
<h3 id="类型擦除的补偿"><a href="#类型擦除的补偿" class="headerlink" title="类型擦除的补偿"></a><a href="#i1rmga"></a>类型擦除的补偿</h3><p>类型擦除导致泛型丧失了一些功能，任何在运行期需要知道确切类型的代码都无法工作。比如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erased</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arg <span class="keyword">instanceof</span> T) &#123;&#125; </span><br><span class="line">        T <span class="keyword">var</span> = <span class="keyword">new</span> T(); </span><br><span class="line">        T[] array = <span class="keyword">new</span> T[SIZE]; </span><br><span class="line">        T[] array = (T)<span class="keyword">new</span> Object[SIZE]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>new T()</code> 创建对象是不行的，一是由于类型擦除，二是由于编译器不知道 <code>T</code> 是否有默认的构造器。一种解决的办法是传递一个工厂对象并且通过它创建新的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FactoryI</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T x;</span><br><span class="line">    <span class="keyword">public</span> &lt;F extends FactoryI&lt;T&gt;&gt; Foo2(F factory) &#123;</span><br><span class="line">        x = factory.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerFactory</span> <span class="keyword">implements</span> <span class="title">FactoryI</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">FactoryI</span>&lt;<span class="title">Widget</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Widget <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Widget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryConstraint</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Foo2&lt;Integer&gt;(<span class="keyword">new</span> IntegerFactory());</span><br><span class="line">        <span class="keyword">new</span> Foo2&lt;Widget&gt;(<span class="keyword">new</span> Widget.Factory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种解决的方法是利用模板设计模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericWithCreate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T element;</span><br><span class="line">    GenericWithCreate() &#123; element = create(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creator</span> <span class="keyword">extends</span> <span class="title">GenericWithCreate</span>&lt;<span class="title">X</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">X <span class="title">create</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> X(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(element.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatorGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Creator c = <span class="keyword">new</span> Creator();</span><br><span class="line">        c.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体类型的创建放到了子类继承父类时，在 <code>create</code> 方法中创建实际的类型并返回。</p>
<p><a name="elwdex"></a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="#elwdex"></a>总结</h2><p>本文介绍了 Java 泛型的使用，以及类型擦除相关的问题。一般情况下泛型的使用比较简单，但是某些情况下，尤其是自己编写使用泛型的类或者方法时要注意类型擦除的问题。接下来会介绍数组与泛型的关系以及通配符的使用，有兴趣的读者可进入下一篇：<a href="https://segmentfault.com/a/1190000005179147" target="_blank" rel="noopener">Java 泛型总结（二）：泛型与数组</a>。</p>
<p><strong>参考</strong></p>
<ul>
<li>Java 编程思想</li>
</ul>
<p><strong><em>如果我的文章对您有帮助，不妨点个赞支持一下(____)</em></strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/22/yuque/Java 泛型总结（一）：基本用法与类型擦除 - Coding - SegmentFault 思否/" data-id="cjxbc1anc0002769pjp8yqllv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/01/22/yuque/Java 泛型总结（三）：通配符的使用 - Coding - SegmentFault 思否/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Java 泛型总结（三）：通配符的使用 - Coding - SegmentFault 思否
        
      </div>
    </a>
  
  
    <a href="/2019/01/22/yuque/Linux下五种IO模型/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Linux下五种IO模型</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/06/25/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2019/06/20/yuque/30个mysql千万级大数据SQL查询优化技巧/">30个mysql千万级大数据SQL查询优化技巧</a>
          </li>
        
          <li>
            <a href="/2019/05/21/yuque/MySQL 性能优化神器 Explain 使用分析/">MySQL 性能优化神器 Explain 使用分析</a>
          </li>
        
          <li>
            <a href="/2019/04/18/yuque/上线之前/">上线之前</a>
          </li>
        
          <li>
            <a href="/2019/03/25/yuque/Java动态追踪技术探究 - 美团技术团队/">Java动态追踪技术探究 - 美团技术团队</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>